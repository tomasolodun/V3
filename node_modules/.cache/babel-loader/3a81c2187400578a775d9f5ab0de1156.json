{"ast":null,"code":"'use strict'; // MODULES //\n\nvar LOW = require('./low.js'); // NOTES //\n\n/**\n* float64 (64 bits)\n* f := fraction (significand/mantissa) (52 bits)\n* e := exponent (11 bits)\n* s := sign bit (1 bit)\n*\n* |-------- -------- -------- -------- -------- -------- -------- --------|\n* |                                Float64                                |\n* |-------- -------- -------- -------- -------- -------- -------- --------|\n* |              Uint32               |               Uint32              |\n* |-------- -------- -------- -------- -------- -------- -------- --------|\n*\n* If little endian (more significant bits last):\n*                         <-- lower      higher -->\n* |   f7       f6       f5       f4       f3       f2    e2 | f1 |s|  e1  |\n*\n* If big endian (more significant bits first):\n*                         <-- higher      lower -->\n* |s| e1    e2 | f1     f2       f3       f4       f5        f6      f7   |\n*\n*\n* Note: in which Uint32 can we find the lower order bits? If LE, the first; if BE, the second.\n* Refs: http://pubs.opengroup.org/onlinepubs/9629399/chap14.htm\n*/\n// VARIABLES //\n\n\nvar FLOAT64_VIEW = new Float64Array(1);\nvar UINT32_VIEW = new Uint32Array(FLOAT64_VIEW.buffer); // SET LOW WORD //\n\n/**\n* FUNCTION: setLowWord( x, low )\n*\tSets the less significant 32 bits of a double-precision floating-point number.\n*\n* @param {Number} x - double\n* @param {Number} low - unsigned 32-bit integer to replace the lower order word of `x`\n* @returns {Number} new double having the same higher order word as `x`\n*/\n\nfunction setLowWord(x, low) {\n  FLOAT64_VIEW[0] = x;\n  UINT32_VIEW[LOW] = low >>> 0; // identity bit shift to ensure integer\n\n  return FLOAT64_VIEW[0];\n} // end FUNCTION setLowWord()\n// EXPORTS //\n\n\nmodule.exports = setLowWord;","map":{"version":3,"sources":["C:/Users/Toma/Desktop/2курс/Теорія ймовірностей/erfc/node_modules/math-float64-set-low-word/lib/index.js"],"names":["LOW","require","FLOAT64_VIEW","Float64Array","UINT32_VIEW","Uint32Array","buffer","setLowWord","x","low","module","exports"],"mappings":"AAAA,a,CAEA;;AAEA,IAAIA,GAAG,GAAGC,OAAO,CAAE,UAAF,CAAjB,C,CAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;;;AAEA,IAAIC,YAAY,GAAG,IAAIC,YAAJ,CAAkB,CAAlB,CAAnB;AACA,IAAIC,WAAW,GAAG,IAAIC,WAAJ,CAAiBH,YAAY,CAACI,MAA9B,CAAlB,C,CAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,UAAT,CAAqBC,CAArB,EAAwBC,GAAxB,EAA8B;AAC7BP,EAAAA,YAAY,CAAE,CAAF,CAAZ,GAAoBM,CAApB;AACAJ,EAAAA,WAAW,CAAEJ,GAAF,CAAX,GAAuBS,GAAG,KAAK,CAA/B,CAF6B,CAEO;;AACpC,SAAOP,YAAY,CAAE,CAAF,CAAnB;AACA,C,CAAC;AAGF;;;AAEAQ,MAAM,CAACC,OAAP,GAAiBJ,UAAjB","sourcesContent":["'use strict';\n\n// MODULES //\n\nvar LOW = require( './low.js' );\n\n\n// NOTES //\n\n/**\n* float64 (64 bits)\n* f := fraction (significand/mantissa) (52 bits)\n* e := exponent (11 bits)\n* s := sign bit (1 bit)\n*\n* |-------- -------- -------- -------- -------- -------- -------- --------|\n* |                                Float64                                |\n* |-------- -------- -------- -------- -------- -------- -------- --------|\n* |              Uint32               |               Uint32              |\n* |-------- -------- -------- -------- -------- -------- -------- --------|\n*\n* If little endian (more significant bits last):\n*                         <-- lower      higher -->\n* |   f7       f6       f5       f4       f3       f2    e2 | f1 |s|  e1  |\n*\n* If big endian (more significant bits first):\n*                         <-- higher      lower -->\n* |s| e1    e2 | f1     f2       f3       f4       f5        f6      f7   |\n*\n*\n* Note: in which Uint32 can we find the lower order bits? If LE, the first; if BE, the second.\n* Refs: http://pubs.opengroup.org/onlinepubs/9629399/chap14.htm\n*/\n\n\n// VARIABLES //\n\nvar FLOAT64_VIEW = new Float64Array( 1 );\nvar UINT32_VIEW = new Uint32Array( FLOAT64_VIEW.buffer );\n\n\n// SET LOW WORD //\n\n/**\n* FUNCTION: setLowWord( x, low )\n*\tSets the less significant 32 bits of a double-precision floating-point number.\n*\n* @param {Number} x - double\n* @param {Number} low - unsigned 32-bit integer to replace the lower order word of `x`\n* @returns {Number} new double having the same higher order word as `x`\n*/\nfunction setLowWord( x, low ) {\n\tFLOAT64_VIEW[ 0 ] = x;\n\tUINT32_VIEW[ LOW ] = ( low >>> 0 ); // identity bit shift to ensure integer\n\treturn FLOAT64_VIEW[ 0 ];\n} // end FUNCTION setLowWord()\n\n\n// EXPORTS //\n\nmodule.exports = setLowWord;\n"]},"metadata":{},"sourceType":"script"}