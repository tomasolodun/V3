{"ast":null,"code":"/* jshint evil:true */\n'use strict'; // EVALPOLY FACTORY //\n\n/**\n* FUNCTION: factory( c )\n*\tReturns a function for evaluating a polynomial.\n*\n* @param {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} c - polynomial coefficients sorted in ascending degree\n* @returns {Function} function for evaluating a polynomial\n*/\n\nfunction factory(c) {\n  var f;\n  var n;\n  var m;\n  var i; // Code generation. Start with the function definition...\n\n  f = 'return function evalpoly(x){'; // Create the function body...\n\n  n = c.length; // If no coefficients, the function always returns 0...\n\n  if (n === 0) {\n    f += 'return 0;';\n  } // If only one coefficient, the function always returns that coefficient...\n  else if (n === 1) {\n      f += 'return ' + c[0] + ';';\n    } // If more than one coefficient, apply Horner's method...\n    else {\n        // If `x == 0`, return the first coefficient...\n        f += 'if(x===0){return ' + c[0] + ';}'; // Otherwise, evaluate the polynomial...\n\n        f += 'return ' + c[0];\n        m = n - 1;\n\n        for (i = 1; i < n; i++) {\n          f += '+x*';\n\n          if (i < m) {\n            f += '(';\n          }\n\n          f += c[i];\n        } // Close all the parentheses...\n\n\n        for (i = 0; i < m - 1; i++) {\n          f += ')';\n        }\n\n        f += ';';\n      } // Close the function:\n\n\n  f += '}'; // Create the function in the global scope:\n\n  return new Function(f)();\n  /**\n  * returns\n  *\tfunction evalpoly( x ) {\n  *\t\tif ( x === 0 ) {\n  *\t\t\treturn c[ 0 ];\n  *\t\t}\n  *\t\treturn c[0]+x*(c[1]+x*(c[2]+x*(c[3]+...+x*(c[n-2]+x*c[n-1]))));\n  *\t}\n  */\n} // end FUNCTION factory()\n// EXPORTS //\n\n\nmodule.exports = factory;","map":{"version":3,"sources":["C:/Users/Toma/Desktop/2курс/Теорія ймовірностей/erfc/node_modules/math-evalpoly/lib/factory.js"],"names":["factory","c","f","n","m","i","length","Function","module","exports"],"mappings":"AAAA;AACA,a,CAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASA,OAAT,CAAkBC,CAAlB,EAAsB;AACrB,MAAIC,CAAJ;AACA,MAAIC,CAAJ;AACA,MAAIC,CAAJ;AACA,MAAIC,CAAJ,CAJqB,CAMrB;;AACAH,EAAAA,CAAC,GAAG,8BAAJ,CAPqB,CASrB;;AACAC,EAAAA,CAAC,GAAGF,CAAC,CAACK,MAAN,CAVqB,CAYrB;;AACA,MAAKH,CAAC,KAAK,CAAX,EAAe;AACdD,IAAAA,CAAC,IAAI,WAAL;AACA,GAFD,CAGA;AAHA,OAIK,IAAKC,CAAC,KAAK,CAAX,EAAe;AACnBD,MAAAA,CAAC,IAAI,YAAYD,CAAC,CAAE,CAAF,CAAb,GAAqB,GAA1B;AACA,KAFI,CAGL;AAHK,SAIA;AACJ;AACAC,QAAAA,CAAC,IAAI,sBAAsBD,CAAC,CAAE,CAAF,CAAvB,GAA+B,IAApC,CAFI,CAIJ;;AACAC,QAAAA,CAAC,IAAI,YAAYD,CAAC,CAAE,CAAF,CAAlB;AACAG,QAAAA,CAAC,GAAGD,CAAC,GAAG,CAAR;;AACA,aAAME,CAAC,GAAG,CAAV,EAAaA,CAAC,GAAGF,CAAjB,EAAoBE,CAAC,EAArB,EAA0B;AACzBH,UAAAA,CAAC,IAAI,KAAL;;AACA,cAAKG,CAAC,GAAGD,CAAT,EAAa;AACZF,YAAAA,CAAC,IAAI,GAAL;AACA;;AACDA,UAAAA,CAAC,IAAID,CAAC,CAAEI,CAAF,CAAN;AACA,SAbG,CAcJ;;;AACA,aAAMA,CAAC,GAAG,CAAV,EAAaA,CAAC,GAAGD,CAAC,GAAC,CAAnB,EAAsBC,CAAC,EAAvB,EAA4B;AAC3BH,UAAAA,CAAC,IAAI,GAAL;AACA;;AACDA,QAAAA,CAAC,IAAI,GAAL;AACA,OAxCoB,CAyCrB;;;AACAA,EAAAA,CAAC,IAAI,GAAL,CA1CqB,CA4CrB;;AACA,SAAS,IAAIK,QAAJ,CAAcL,CAAd,CAAF,EAAP;AAEA;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACC,C,CAAC;AAGF;;;AAEAM,MAAM,CAACC,OAAP,GAAiBT,OAAjB","sourcesContent":["/* jshint evil:true */\n'use strict';\n\n// EVALPOLY FACTORY //\n\n/**\n* FUNCTION: factory( c )\n*\tReturns a function for evaluating a polynomial.\n*\n* @param {Number[]|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} c - polynomial coefficients sorted in ascending degree\n* @returns {Function} function for evaluating a polynomial\n*/\nfunction factory( c ) {\n\tvar f;\n\tvar n;\n\tvar m;\n\tvar i;\n\n\t// Code generation. Start with the function definition...\n\tf = 'return function evalpoly(x){';\n\n\t// Create the function body...\n\tn = c.length;\n\n\t// If no coefficients, the function always returns 0...\n\tif ( n === 0 ) {\n\t\tf += 'return 0;';\n\t}\n\t// If only one coefficient, the function always returns that coefficient...\n\telse if ( n === 1 ) {\n\t\tf += 'return ' + c[ 0 ] + ';';\n\t}\n\t// If more than one coefficient, apply Horner's method...\n\telse {\n\t\t// If `x == 0`, return the first coefficient...\n\t\tf += 'if(x===0){return ' + c[ 0 ] + ';}';\n\n\t\t// Otherwise, evaluate the polynomial...\n\t\tf += 'return ' + c[ 0 ];\n\t\tm = n - 1;\n\t\tfor ( i = 1; i < n; i++ ) {\n\t\t\tf += '+x*';\n\t\t\tif ( i < m ) {\n\t\t\t\tf += '(';\n\t\t\t}\n\t\t\tf += c[ i ];\n\t\t}\n\t\t// Close all the parentheses...\n\t\tfor ( i = 0; i < m-1; i++ ) {\n\t\t\tf += ')';\n\t\t}\n\t\tf += ';';\n\t}\n\t// Close the function:\n\tf += '}';\n\n\t// Create the function in the global scope:\n\treturn ( new Function( f ) )();\n\n\t/**\n\t* returns\n\t*\tfunction evalpoly( x ) {\n\t*\t\tif ( x === 0 ) {\n\t*\t\t\treturn c[ 0 ];\n\t*\t\t}\n\t*\t\treturn c[0]+x*(c[1]+x*(c[2]+x*(c[3]+...+x*(c[n-2]+x*c[n-1]))));\n\t*\t}\n\t*/\n} // end FUNCTION factory()\n\n\n// EXPORTS //\n\nmodule.exports = factory;"]},"metadata":{},"sourceType":"script"}