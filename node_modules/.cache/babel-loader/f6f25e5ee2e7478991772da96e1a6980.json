{"ast":null,"code":"'use strict'; // MODULES //\n\nvar ctors = require('./ctors.js'); // IS LITTLE ENDIAN //\n\n/**\n* FUNCTION: isLittleEndian()\n*\tReturns a boolean indicating if an environment is little endian.\n*\n* @returns {Boolean} boolean indicating if an environment is little endian\n*/\n\n\nfunction isLittleEndian() {\n  var uint16_view;\n  var uint8_view;\n  uint16_view = new ctors['uint16'](1); // Set the uint16 view to a value having distinguishable lower and higher order words.\n  // 4660 => 0x1234 => 0x12 0x34 => '00010010 00110100' => (0x12,0x34) == (18,52)\n\n  uint16_view[0] = 0x1234; // Create a uint8 view on top of the uint16 buffer:\n\n  uint8_view = new ctors['uint8'](uint16_view.buffer); // If little endian, the least significant byte will be first...\n\n  return uint8_view[0] === 0x34;\n} // end FUNCTION isLittleEndian()\n// EXPORTS //\n\n\nmodule.exports = isLittleEndian();","map":{"version":3,"sources":["C:/Users/Toma/Desktop/2курс/Теорія ймовірностей/erfc/node_modules/utils-is-little-endian/lib/index.js"],"names":["ctors","require","isLittleEndian","uint16_view","uint8_view","buffer","module","exports"],"mappings":"AAAA,a,CAEA;;AAEA,IAAIA,KAAK,GAAGC,OAAO,CAAE,YAAF,CAAnB,C,CAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,cAAT,GAA0B;AACzB,MAAIC,WAAJ;AACA,MAAIC,UAAJ;AAEAD,EAAAA,WAAW,GAAG,IAAIH,KAAK,CAAE,QAAF,CAAT,CAAuB,CAAvB,CAAd,CAJyB,CAMzB;AACA;;AACAG,EAAAA,WAAW,CAAE,CAAF,CAAX,GAAmB,MAAnB,CARyB,CAUzB;;AACAC,EAAAA,UAAU,GAAG,IAAIJ,KAAK,CAAE,OAAF,CAAT,CAAsBG,WAAW,CAACE,MAAlC,CAAb,CAXyB,CAazB;;AACA,SAASD,UAAU,CAAE,CAAF,CAAV,KAAoB,IAA7B;AACA,C,CAAC;AAGF;;;AAEAE,MAAM,CAACC,OAAP,GAAiBL,cAAc,EAA/B","sourcesContent":["'use strict';\n\n// MODULES //\n\nvar ctors = require( './ctors.js' );\n\n\n// IS LITTLE ENDIAN //\n\n/**\n* FUNCTION: isLittleEndian()\n*\tReturns a boolean indicating if an environment is little endian.\n*\n* @returns {Boolean} boolean indicating if an environment is little endian\n*/\nfunction isLittleEndian() {\n\tvar uint16_view;\n\tvar uint8_view;\n\n\tuint16_view = new ctors[ 'uint16' ]( 1 );\n\n\t// Set the uint16 view to a value having distinguishable lower and higher order words.\n\t// 4660 => 0x1234 => 0x12 0x34 => '00010010 00110100' => (0x12,0x34) == (18,52)\n\tuint16_view[ 0 ] = 0x1234;\n\n\t// Create a uint8 view on top of the uint16 buffer:\n\tuint8_view = new ctors[ 'uint8' ]( uint16_view.buffer );\n\n\t// If little endian, the least significant byte will be first...\n\treturn ( uint8_view[ 0 ] === 0x34 );\n} // end FUNCTION isLittleEndian()\n\n\n// EXPORTS //\n\nmodule.exports = isLittleEndian();\n"]},"metadata":{},"sourceType":"script"}